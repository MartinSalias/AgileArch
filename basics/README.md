# Agile & Software Architecture

Software development is a pretty new discipline. It started in theory with Charles Babbage and his Differential Engine, and Lady Augusta Ada Byron, Countess of Lovelace, becoming the first programmer in history, although she never had the actual computer to execute her programs!

From these early days to Word War II, computing turned from theory to a mean to push mathemathics to a larger scale, and remained as an academic endeavor until the early 50's, with the Univac. Later that decade IBM starts producing their first commercials computers and programmers start spreading from mathematicians to engineers, and a new species was born: the homo-nerdus, also known as "computer programmer".

Early programming methods were pretty much ad-hoc, and the cycle between coding and compilation could be measured in weeks, from punching the cards (which sometimes the coder could not do on herself) to submitting the batch of cards to the Computer's Administrators and wait days to receive back a paper listing with the result run or just pages of error information. 

As computers became popular in the corporate world and software applications got more complex, the need to stronger engineering practices appeared, and from 70's to 90's our industry exported ideas and processes from the previous engineering fields, from electronics to civil construction. The result introduced several problems, basically because programmers got subjected to controls and environments closer to blue-collar workers than designers, most of the time restricting innovation and creativity.

Agile software development crystalized at the start of the XXI century as a reaction to these prescriptive processes, putting the focus back in the non-repetitive side of programming, fostering relationships, team dynamics, collaboration outside of the technical roles, and maximizing feedback loops everywhere.

In the first part of this book I want to provide a short recap of its main topics, just to set expectations, boundaries and terminology I will use in the resto of the book, and as a pivot for further discussion.

First I will review the Agile paradigm from the values and principles and the practices in he most common frameworks like Scrum and Extreme Programming, its Lean cousin Kanban, and then what I understand as the meta-model behind Agile.

Then I will do the same with Software Architecture, focusing mostly in the type of Architecture I will refer to in this book, and pointing to connected disciplines.

Lastly I want to present my view of the main challenges Software Architecture face on Agile teams, projects and organizations, and provide a short overview of the different approaches I present about this topic during the rest of the book.



